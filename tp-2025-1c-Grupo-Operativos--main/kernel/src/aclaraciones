• Protocolo de Comunicación: Tiene códigos de operación definidos (ej. INICIAR_PROCESO, EJECUTAR_PROCESO, SYSCALL, IO_PEDIDO, IO_FINISHED, OK, CPU_FINISHED, etc.). Estos estan definidos en un archivo de encabezado común 
• 
Lógica Mock de Memoria: El módulo de Memoria en este código para la Entrega 2 solo devuelve un OK simulado al pedido de inicialización. En la Entrega 3, la gestión real de la memoria se implementará.
•
Gestión de Conexiones: La aceptación de clientes (CPUs e IOs) se realiza en el main. La función esperar_cliente ahora también maneja el handshake inicial de los módulos IO para registrar sus nombres.
•
Planificación FIFO: Se implementa la lógica básica de colas FIFO para la planificación de largo y corto plazo.
•
Administración de IO: Se incluye la lógica para bloquear procesos por IO y la interacción básica con el módulo IO.
•
Syscalls: Se manejan las syscalls INIT_PROC (creando un PCB y agregándolo a la cola NEW) y IO (moviendo el proceso a la cola de bloqueados y notificando al módulo IO). También se incluye un manejo básico para la syscall EXIT.
•
Estado de los Procesos: Se utiliza la enumeración t_estado para rastrear el estado de los procesos.
•
Listas y Diccionarios: Se utilizan las estructuras de datos de las Commons (t_list y t_dictionary) para las colas y el registro de dispositivos IO.